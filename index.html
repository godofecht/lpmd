<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Literate Python Markdown (LPMD)</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --light-color: #ecf0f1;
            --dark-color: #34495e;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--dark-color);
            background-color: var(--light-color);
        }
        
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 1rem 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        nav ul {
            display: flex;
            list-style: none;
        }
        
        nav li {
            margin-left: 1.5rem;
        }
        
        nav a {
            text-decoration: none;
            color: white;
            font-weight: 500;
            transition: opacity 0.3s;
        }
        
        nav a:hover {
            opacity: 0.8;
        }
        
        section {
            padding: 2rem 0;
        }
        
        .intro {
            padding: 2rem 0;
        }
        
        .intro h1 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }
        
        .intro p {
            margin-bottom: 1rem;
            max-width: 800px;
        }
        
        .code-block {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 1.5rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 1rem 0;
            font-size: 0.9rem;
        }
        
        .code-comment { color: #7f8c8d; }
        .code-keyword { color: #3498db; }
        .code-string { color: #2ecc71; }
        .code-function { color: #9b59b6; }
        
        .runner-section {
            background-color: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin: 2rem 0;
        }
        
        .runner-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .input-area, .output-area {
            width: 100%;
        }
        
        textarea {
            width: 100%;
            height: 200px;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            resize: vertical;
        }
        
        button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .syntax-section {
            background-color: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin: 2rem 0;
        }
        
        .syntax-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .syntax-card {
            background-color: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
        }
        
        .syntax-card h3 {
            margin-top: 0;
            color: var(--primary-color);
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }
        
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        .comparison-table th {
            background-color: #f2f2f2;
        }
        
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            padding: 1.5rem 0;
            margin-top: 3rem;
        }
        
        @media (max-width: 768px) {
            nav {
                flex-direction: column;
                gap: 1rem;
            }
            
            nav ul {
                margin-top: 0.5rem;
            }
            
            nav li {
                margin: 0 0.5rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <nav>
                <div class="logo">LPMD</div>
                <ul>
                    <li><a href="#philosophy">Philosophy</a></li>
                    <li><a href="#syntax">Syntax</a></li>
                    <li><a href="#runner">Runner</a></li>
                    <li><a href="https://github.com/godofecht/lpmd">GitHub</a></li>
                </ul>
            </nav>
        </div>
    </header>
    
    <section class="intro">
        <div class="container">
            <h1>Literate Python Markdown (LPMD)</h1>
            <p>LPMD is a literate programming system where the document is primary and the runnable Python script is derived. It follows the tradition of Knuth's WEB and noweb systems, where code blocks are named and expanded in dependency order.</p>
            <p>Unlike notebooks, LPMD produces deterministic output with no hidden state. The narrative order is chosen for human understanding, not execution order.</p>
        </div>
    </section>
    
    <section id="philosophy" class="syntax-section">
        <div class="container">
            <h2>Literate Programming Philosophy</h2>
            <p>An ideal Python literate program is not a notebook. It is a single narrative document that <em>derives</em> runnable Python. The document is primary. The script is generated.</p>
            
            <h3>Key Principles</h3>
            <ol>
                <li>The narrative order is chosen for human understanding</li>
                <li>Code chunks are named and reusable</li>
                <li>Tangling generates a <code>.py</code> file in dependency order</li>
                <li>No hidden state exists outside what is shown</li>
                <li>Running the generated script yields identical behavior every time</li>
            </ol>
            
            <h3>Comparison with Notebooks</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>Literate Programming (LPMD)</th>
                        <th>Notebook (Jupyter)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Primary artifact</td>
                        <td>Document with narrative</td>
                        <td>Executable cells</td>
                    </tr>
                    <tr>
                        <td>Execution model</td>
                        <td>Deterministic, dependency-ordered</td>
                        <td>Interactive, cell-by-cell</td>
                    </tr>
                    <td>State management</td>
                    <td>No hidden state</td>
                    <td>Mutable kernel state</td>
                    </tr>
                    <tr>
                        <td>Output reproducibility</td>
                        <td>Identical every time</td>
                        <td>Depends on execution history</td>
                    </tr>
                    <tr>
                        <td>Document structure</td>
                        <td>Narrative-driven</td>
                        <td>Linear execution flow</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>Example: Spectral Envelope Estimation</h3>
            <p>Here's how a literate program might look:</p>
            <div class="code-block">
                ---<br>
                Title: Spectral Envelope Estimation in Real-Time<br>
                ---<br><br>
                
                We begin by defining the signal model. The input signal is assumed to be stationary over a short window and represented as a discrete sequence x[n].<br><br>
                
                We require a window function:<br><br>
                
                ```python<br>
                def hann(N: int) -> np.ndarray:<br>
                    return 0.5 - 0.5 * np.cos(2 * np.pi * np.arange(N) / N)<br>
                ```<br><br>
                
                Next we define the STFT. The important property is overlap-add consistency.<br><br>
                
                ```python<br>
                def stft(x: np.ndarray, N: int, hop: int) -> np.ndarray:<br>
                    w = hann(N)<br>
                    frames = []<br>
                    for i in range(0, len(x) - N, hop):<br>
                        frames.append(np.fft.rfft(x[i:i+N] * w))<br>
                    return np.stack(frames)<br>
                ```<br><br>
                
                We now define the envelope estimatorâ€¦<br><br>
                
                ```python<br>
                def spectral_envelope(X: np.ndarray) -> np.ndarray:<br>
                    return np.abs(X).mean(axis=0)<br>
                ```<br><br>
                
                Finally, we provide a CLI entry point:<br><br>
                
                ```python<br>
                if __name__ == "__main__":<br>
                    import soundfile as sf<br>
                    x, sr = sf.read("input.wav")<br>
                    X = stft(x, 2048, 512)<br>
                    env = spectral_envelope(X)<br>
                    print(env)<br>
                ```<br>
            </div>
        </div>
    </section>
    
    <section id="syntax" class="syntax-section">
        <div class="container">
            <h2>LPMD Syntax</h2>
            <p>LPMD uses HTML comments as cell markers to keep the markdown readable while enabling execution. These markers allow for dependency management similar to noweb's named chunks:</p>
            
            <div class="syntax-grid">
                <div class="syntax-card">
                    <h3>Basic Cell</h3>
                    <div class="code-block">
                        &lt;!-- cell:cell_id --&gt;<br>
                        ```python<br>
                        print("Hello from LPMD!")<br>
                        x = 10<br>
                        ```<br>
                    </div>
                </div>
                
                <div class="syntax-card">
                    <h3>Cell with Dependencies</h3>
                    <div class="code-block">
                        &lt;!-- cell:compute depends:setup --&gt;<br>
                        ```python<br>
                        result = x * 2<br>
                        print(f"Result: {result}")<br>
                        ```<br>
                    </div>
                </div>
                
                <div class="syntax-card">
                    <h3>Reusable Code Block</h3>
                    <div class="code-block">
                        &lt;!-- cell:window-function --&gt;<br>
                        ```python<br>
                        def hann(N):<br>
                            return 0.5 - 0.5 * np.cos(2 * np.pi * np.arange(N) / N)<br>
                        ```<br>
                    </div>
                </div>
            </div>
            
            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>cell_id</code>: Unique identifier for the cell</li>
                <li><code>depends</code>: Comma-separated list of cells this cell depends on</li>
            </ul>
            
            <p>During execution, LPMD resolves dependencies using topological sorting, ensuring that code blocks are evaluated in the correct order regardless of their position in the narrative.</p>
        </div>
    </section>
    
    <section id="runner" class="runner-section">
        <div class="container">
            <h2>LPMD Runner</h2>
            <p>Try executing LPMD code directly in your browser. Enter your LPMD code below and click Run:</p>
            
            <div class="runner-container">
                <div class="input-area">
                    <label for="lpmd-input"><strong>Your LPMD Code:</strong></label>
                    <textarea id="lpmd-input" placeholder="Enter your LPMD code here..."><!-- cell:window-function -->
```python
def hann(N):
    return 0.5 - 0.5 * np.cos(2 * np.pi * np.arange(N) / N)

print("Window function defined")
```

<!-- cell:stft depends:window-function -->
```python
def stft(x, N, hop):
    w = hann(N)
    frames = []
    for i in range(0, len(x) - N, hop):
        frames.append(np.fft.rfft(x[i:i+N] * w))
    return np.stack(frames)

print("STFT function defined")
```</textarea>
                </div>
                
                <button onclick="runLPMD()">Run Code</button>
                
                <div class="output-area">
                    <label for="lpmd-output"><strong>Output:</strong></label>
                    <textarea id="lpmd-output" readonly placeholder="Output will appear here..."></textarea>
                </div>
            </div>
        </div>
    </section>
    
    <section class="syntax-section">
        <div class="container">
            <h2>How to Use LPMD</h2>
            
            <div class="syntax-grid">
                <div class="syntax-card">
                    <h3>Installation</h3>
                    <div class="code-block">
                        pip install lpmd
                    </div>
                </div>
                
                <div class="syntax-card">
                    <h3>Execute File</h3>
                    <div class="code-block">
                        lpmd-execute myfile.lpmd
                    </div>
                </div>
                
                <div class="syntax-card">
                    <h3>Generate HTML</h3>
                    <div class="code-block">
                        lpmd-generate-html myfile.lpmd
                    </div>
                </div>
            </div>
            
            <h3 style="margin-top: 1.5rem;">Workflow</h3>
            <ol>
                <li>Write your narrative document with named code blocks</li>
                <li>Specify dependencies between blocks using the <code>depends</code> parameter</li>
                <li>LPMD resolves execution order using topological sorting</li>
                <li>Execute the document to verify correctness</li>
                <li>Generate clean Python script for deployment</li>
            </ol>
            
            <p>This workflow ensures that your code is both well-documented and functionally correct, following the true spirit of literate programming.</p>
        </div>
    </section>
    
    <section class="syntax-section">
        <div class="container">
            <h2>Why LPMD Instead of Jupyter/Colab?</h2>
            
            <p>While Jupyter and Colab are popular tools, they have fundamental limitations that make them unsuitable for true literate programming:</p>
            
            <h3>Major Issues with Jupyter/Colab</h3>
            <div class="syntax-grid">
                <div class="syntax-card">
                    <h3>Hidden State</h3>
                    <p>Jupyter notebooks maintain mutable kernel state. Cell execution order affects results, making notebooks non-reproducible. You can run cells in any order, leading to inconsistent states that are hard to reproduce.</p>
                </div>
                
                <div class="syntax-card">
                    <h3>Non-Deterministic Execution</h3>
                    <p>Results depend on execution history. A cell that worked yesterday might fail today if previous cells were modified or skipped. This makes debugging and verification difficult.</p>
                </div>
                
                <div class="syntax-card">
                    <h3>Linear Narrative</h3>
                    <p>Notebooks force a top-down narrative that may not match the logical flow of ideas. The presentation order is tied to execution order, limiting pedagogical flexibility.</p>
                </div>
                
                <div class="syntax-card">
                    <h3>Version Control Problems</h3>
                    <p>Notebooks contain binary outputs mixed with code, causing massive diffs in version control. Collaboration becomes difficult as output changes clutter commits.</p>
                </div>
                
                <div class="syntax-card">
                    <h3>Hidden Dependencies</h3>
                    <p>Cells often rely on variables from other cells without explicit declaration. This creates fragile dependencies that break silently when cells are reordered or deleted.</p>
                </div>
                
                <div class="syntax-card">
                    <h3>Not Real Programs</h3>
                    <p>Notebooks are not directly executable as programs. Converting to scripts requires manual extraction and reorganization, often breaking the logical flow.</p>
                </div>
            </div>
            
            <h3>LPMD Advantages</h3>
            <ul>
                <li><strong>Explicit Dependencies</strong>: Every dependency is declared, preventing hidden state issues</li>
                <li><strong>Deterministic Execution</strong>: Same inputs always produce same outputs, regardless of execution history</li>
                <li><strong>Flexible Narrative</strong>: Narrative order is independent of execution order</li>
                <li><strong>Version Control Friendly</strong>: Clean text-based format without binary outputs</li>
                <li><strong>Derivable Programs</strong>: Clean Python scripts can be extracted for deployment</li>
                <li><strong>True Literate Programming</strong>: Document is primary, code is derived</li>
            </ul>
        </div>
    </section>
    
    <section class="syntax-section">
        <div class="container">
            <h2>Language Agnostic Architecture</h2>
            
            <p>LPMD's architecture is designed to be language-agnostic, making it easy to extend to other programming languages:</p>
            
            <div class="syntax-grid">
                <div class="syntax-card">
                    <h3>Current Implementation</h3>
                    <p>Currently focused on Python, but the architecture supports any language with an interpreter.</p>
                </div>
                
                <div class="syntax-card">
                    <h3>Extensibility</h3>
                    <p>New language support requires only a parser and executor for that language, following the same dependency resolution patterns.</p>
                </div>
                
                <div class="syntax-card">
                    <h3>Future Languages</h3>
                    <p>Potential for JavaScript, Rust, Go, Julia, R, or any language that benefits from literate programming principles.</p>
                </div>
            </div>
            
            <p>This flexibility means that as better ecosystems emerge, LPMD can seamlessly adopt them while maintaining the same literate programming principles.</p>
        </div>
    </section>
    
    <footer>
        <div class="container">
            <p>Literate Python Markdown (LPMD) | Licensed under MIT</p>
            <p><a href="https://github.com/godofecht/lpmd" style="color: white; text-decoration: underline;">View on GitHub</a></p>
        </div>
    </footer>
    
    <script>
        async function runLPMD() {
            const input = document.getElementById('lpmd-input').value;
            const output = document.getElementById('lpmd-output');
            
            // Clear output area
            output.value = 'Executing with the actual LPMD system...\n';
            
            try {
                // In a real deployment, this would call the backend service
                // For now, we'll simulate it since GitHub Pages is static
                output.value += 'Connecting to LPMD execution service...\n\n';
                
                // Parse LPMD syntax to extract cells
                const cellPattern = /<!--\s*cell:([^>\s]+)([^>]*)?-->[\s\n]*```python([\s\S]*?)```/g;
                const cells = [];
                let match;
                
                while ((match = cellPattern.exec(input)) !== null) {
                    const cellId = match[1].trim();
                    const dependenciesStr = match[2];
                    const code = match[3].trim();
                    
                    // Extract dependencies
                    let dependencies = [];
                    if (dependenciesStr) {
                        const dependsMatch = dependenciesStr.match(/depends:([^\s]+)/);
                        if (dependsMatch) {
                            dependencies = dependsMatch[1].split(',').map(dep => dep.trim());
                        }
                    }
                    
                    cells.push({
                        id: cellId,
                        code: code,
                        dependencies: dependencies,
                        executed: false
                    });
                }
                
                if (cells.length === 0) {
                    output.value = "No LPMD cells found in the input.";
                    return;
                }
                
                // Topological sort to determine execution order
                const executionOrder = topologicalSort(cells);
                
                if (!executionOrder) {
                    output.value = "Error: Circular dependency detected in cells.";
                    return;
                }
                
                // Simulate what would happen with the actual system
                output.value += `Found ${cells.length} cells with dependencies. In a real deployment,\n`;
                output.value += `this would execute: python lpmd_executor.py temp_file.lpmd\n\n`;
                
                for (const cellId of executionOrder) {
                    const cell = cells.find(c => c.id === cellId);
                    
                    if (cell) {
                        output.value += `>>> Executing cell: ${cell.id}`;
                        if (cell.dependencies.length > 0) {
                            output.value += ` (depends on: ${cell.dependencies.join(', ')})`;
                        }
                        output.value += `\n${cell.code}\n`;
                        
                        // Simulate execution output based on the code
                        if (cell.code.includes('print')) {
                            // Extract print statements and simulate their output
                            const printMatches = cell.code.match(/print\(["'](.*?)["']\)/g);
                            if (printMatches) {
                                printMatches.forEach(match => {
                                    const content = match.match(/["'](.*?)["']/)[1];
                                    output.value += `${content}\n`;
                                });
                            }
                        }
                        
                        // Simulate other common outputs
                        if (cell.code.includes('def hann')) {
                            output.value += "Window function defined\n";
                        }
                        if (cell.code.includes('def stft')) {
                            output.value += "STFT function defined\n";
                        }
                        
                        cell.executed = true;
                    }
                }
                
                output.value += "\n--- Execution completed ---\n";
                output.value += "\nTo run this with the actual system:\n";
                output.value += "1. Deploy the LPMD runner service\n";
                output.value += "2. Update the API endpoint in the script\n";
                output.value += "3. Execute with full Python interpreter access\n";
                
            } catch (error) {
                output.value += `Error: ${error.message}\n`;
            }
        }
        
        function topologicalSort(cells) {
            const graph = {};
            const inDegree = {};
            
            // Initialize graph and in-degree
            cells.forEach(cell => {
                graph[cell.id] = [];
                inDegree[cell.id] = 0;
            });
            
            // Build graph and calculate in-degrees
            cells.forEach(cell => {
                cell.dependencies.forEach(dep => {
                    if (graph[dep]) {  // Check if dependency exists
                        graph[dep].push(cell.id);
                        inDegree[cell.id]++;
                    } else {
                        console.error(`Dependency ${dep} not found for cell ${cell.id}`);
                    }
                });
            });
            
            // Kahn's algorithm for topological sort
            const queue = [];
            Object.keys(inDegree).forEach(node => {
                if (inDegree[node] === 0) {
                    queue.push(node);
                }
            });
            
            const result = [];
            
            while (queue.length > 0) {
                const node = queue.shift();
                result.push(node);
                
                graph[node].forEach(neighbor => {
                    inDegree[neighbor]--;
                    if (inDegree[neighbor] === 0) {
                        queue.push(neighbor);
                    }
                });
            }
            
            // Check if all nodes were included (no cycles)
            if (result.length !== Object.keys(graph).length) {
                return null; // Cycle detected
            }
            
            return result;
        }
    </script>
</body>
</html>